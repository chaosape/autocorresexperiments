theory scratch imports
  "../../tools/autocorres/AutoCorres"
begin
(*
declare [[show_types]]
declare [[show_sorts]]
declare [[show_consts]]
*)
(*install_C_file "/home/dacosta/scratch/minmax.c"
autocorres "/home/dacosta/scratch/minmax.c"

context minmax begin

lemma min'_is_min: "min' a b = min a b" 
  unfolding min_def min'_def 
  by (rule refl)

thm max'_def

thm word_le_def

thm word_n1_ge

thm uint_minus_simple_alt

lemma subtraction_by_UINT_MAX_flips_inequalities: "((a::word32) \<le> b) = ((-1 - a) \<ge> (-1 - b))"
apply (subst word_le_def)+
apply (subst word_n1_ge [simplified uint_minus_simple_alt])+
apply arith
done

value "- (1::word32) - (0xFFFFFFFF::word32)"

lemma max'_is_max: "max' a b = max a b"
apply (subst max'_def)
apply (subst min'_def)
apply (subst max_def)
apply (subst subtraction_by_UINT_MAX_flips_inequalities)
apply force
done
end
*)
(*
install_C_file "/home/dacosta/scratch/mult_by_add.c"
autocorres [ ts_rules = nondet ] "/home/dacosta/scratch/mult_by_add.c"

context mult_by_add begin

thm "field_simps"

lemma mult_by_add_correct: "\<lbrace> \<lambda> s. True \<rbrace> mult_by_add' a b \<lbrace> \<lambda> r s. r = a * b \<rbrace>!"
apply (unfold mult_by_add'_def)
apply (subst whileLoop_add_inv [where I = "\<lambda>(b',r) s. r = (b - b') * a" 
                                and M = "\<lambda>((b',r),s). b'"])
apply wp
apply (simp add: field_simps)
apply unat_arith
apply (auto simp: field_simps not_less)
done

end
*)

(*
install_C_file "/home/dacosta/scratch/swap.c"
autocorres [ ts_rules = nondet ] "/home/dacosta/scratch/swap.c"

context swap begin

thm "swap'_def"

lemma "\<lbrace> \<lambda>s. is_valid_w32 s a \<and> heap_w32 s a = x \<and> is_valid_w32 s b \<and> heap_w32 s b = y \<and> a \<noteq> b \<rbrace> swap' a b \<lbrace> \<lambda> r s. is_valid_w32 s a \<and> heap_w32 s a = y \<and> is_valid_w32 s b \<and> heap_w32 s b = x\<rbrace>!"
apply (unfold swap'_def)
apply wp
apply (clarsimp simp: fun_upd_apply)
done

end
*)
(*
install_C_file "/home/dacosta/scratch/amax.c"
autocorres [ ts_rules = nondet ] "/home/dacosta/scratch/amax.c"
context amax begin

lemma ptr_add_assoc [simp]:
  "p +\<^sub>p (i + j) = p +\<^sub>p i +\<^sub>p j"
  by (simp add: CTypesDefs.ptr_add_def distrib_right)

lemma ptr_add_commute [simp]:
  "p +\<^sub>p i +\<^sub>p j = p +\<^sub>p j +\<^sub>p i"
  by (metis ptr_add_assoc add.commute)

fun
  forall_elems :: "(32 word ptr \<Rightarrow> bool) \<Rightarrow> lifted_globals \<Rightarrow> word32 ptr \<Rightarrow> nat \<Rightarrow> bool"
where
  "forall_elems P s a 0 = True" |
  "forall_elems P s a (Suc n) = (P a \<and> forall_elems P s (a +\<^sub>p 1) n)"

fun
  exists_elems :: "(32 word ptr \<Rightarrow> bool) \<Rightarrow> lifted_globals \<Rightarrow> word32 ptr \<Rightarrow> nat \<Rightarrow> bool"
where
  "exists_elems P s a 0 = False" |
  "exists_elems P s a (Suc n) = (P a \<or> exists_elems P s (a +\<^sub>p 1) n)"

definition
  array_loc_valid :: "word32 ptr \<Rightarrow> nat \<Rightarrow> bool"
where
  "array_loc_valid a n \<equiv> (unat (ptr_val a) + size_of TYPE(word32) * n < 2 ^ len_of TYPE(32))"

lemma array_all_elems_valid:
  (* equivalent characterisation of array validity *)
  "forall_elems (\<lambda> k. is_valid_w32 s k) s a n = (\<forall>m. m < n \<longrightarrow> is_valid_w32 s (a +\<^sub>p int m))"
  apply (induct n arbitrary: a)
   apply simp
  apply (case_tac "n = 0")
   apply simp
  apply (rule iffI)
   apply clarsimp
   apply (case_tac "m = 0")
    apply simp
   apply (case_tac "m = n")
    apply clarsimp
    apply (drule_tac x = "n - 1" in spec)
    apply (simp add: CTypesDefs.ptr_add_def)
   apply (drule_tac x = "m - 1" in spec)
   apply (simp add: CTypesDefs.ptr_add_def)
  apply simp
  apply (frule_tac x = "0" in spec)
  apply clarsimp
  apply (frule_tac x = "m + 1" in spec)
  apply simp
  done

definition
  is_array :: "lifted_globals \<Rightarrow> word32 ptr \<Rightarrow> nat \<Rightarrow> bool"
where
  "is_array s a n \<equiv> (array_loc_valid a n \<and> forall_elems (\<lambda> k. is_valid_w32 s k) s a n)"

thm "amax'_def"

lemma "
  \<lbrace> \<lambda> s::lifted_globals.  l \<ge> 1 \<and> is_array s a (unat l) \<rbrace> 
 amax' l a
  \<lbrace> \<lambda> m (s::lifted_globals). 
is_array s a (unat l)
\<and> (\<exists> k. exists_elems (\<lambda> k'. k = k' \<and> heap_w32 s k = m) s a (unat l) 
   \<and> forall_elems (\<lambda> k'. heap_w32 s k' \<le> heap_w32 s k') s a (unat l))
  \<rbrace>!
"
apply (rule validNF_assume_pre)
apply (unfold amax'_def)
apply (subst whileLoop_add_inv [where I = 
"\<lambda> (i,j) s.
(\<exists> k. exists_elems (\<lambda> k'. k = k' \<and> heap_w32 s k = j) s a (unat i) 
   \<and> forall_elems (\<lambda> k'. heap_w32 s k' \<le> heap_w32 s k') s a (unat i))
" 
and M = "\<lambda>((i,j),s). l - i"])
apply wp
apply (clarsimp simp add: is_array_def array_loc_valid_def)
apply unat_arith
sorry
end
*)

(* TRY SUM *)

install_C_file "/home/dacosta/scratch/sum.c"
autocorres [ ts_rules = nondet ] "/home/dacosta/scratch/sum.c"
context sum begin
thm sum'_def

lemma desired: "(i::nat)<a \<Longrightarrow> a+i*i < a * a \<or> a*a = (a+i*i)"
proof (induct a arbitrary: i)
  case 0
  thus ?case by auto
next
  case (Suc a)
  have "i = a \<or> i < a" using Suc by auto
  then show ?case
  proof
    assume "i = a"
    thus ?case by auto
  next  
    assume A:"i < a"
    hence B:"0 < a" by simp
    have "a + i * i < a * a \<or> a * a = a + i * i" using Suc(1)[OF A] by simp
    then show ?case 
    proof
      assume "a + i * i < a * a"
      hence "a + i * i + 1 \<le> a * a" by simp
      hence "Suc a + i * i \<le>  a * a" and "a * a < Suc a * Suc a" by simp+
      hence "Suc a + i * i < Suc a * Suc a" by simp
      thus ?case by simp
    next 
      assume C:"a * a = a + i * i"
      hence "a * a + 1 = Suc a + i * i" by simp
      have "a * a + 1 < Suc a * Suc a" using B by simp
      hence "Suc a * Suc a > Suc a + i * i" using C by simp
      hence "Suc a + i * i < Suc a * Suc a" by simp
      thus ?case by simp
    qed
  qed
qed

lemma "\<lbrace> \<lambda> a. i' \<le> x \<rbrace> 
do (i::nat, s) \<leftarrow>
   whileLoop (\<lambda>(i, _) a. i \<le> x)
     (\<lambda>(i, s). return (i + 1, s + i))
    (i', s');
   return s
od
 \<lbrace> \<lambda> s a.  s*2 = s'*2 + ((x*x - i*i) + x + i) \<rbrace>!
"
apply (rule validNF_assume_pre)
apply clarsimp
apply (subst whileLoop_add_inv [where I = " \<lambda> (i,s) a. (i' < i \<and> i \<le> x + 1 \<and> s*2 = s'*2 + (i*i - i - i'*i' + i')) \<or> (i = i' \<and> s = s')" and M = "\<lambda>((i',s'),a). (x + 1) - i'"])
apply wp
apply clarsimp
apply (auto simp: algebra_simps)
proof -
  assume "i' < a"
  

(*using le_add1 le_add_diff_inverse le_square le_trans apply blast
try *)
(*
lemma " \<lbrace> \<lambda> a. x - i < 92680 \<and> s < 2^32 - i^2*i  \<rbrace> 
do (i\<Colon>32 word, s\<Colon>32 word) \<leftarrow>
   whileLoop (\<lambda>(i\<Colon>32 word, s'\<Colon>32 word) a\<Colon>lifted_globals. i \<le> x)
     (\<lambda>(i\<Colon>32 word, s\<Colon>32 word). return (i + (1\<Colon>32 word), s + i))
    (i\<Colon>32 word, s\<Colon>32 word);
   return s
od
 \<lbrace> \<lambda> s' a.  s' \<ge> s  \<rbrace>!
"
apply clarsimp
apply (subst whileLoop_add_inv [where I = " \<lambda> (i',s') a. x \<le> 10 \<and> i \<le> 10 \<and> s \<le> 10 \<and> s' \<ge> s" and M = "\<lambda>((i',s'),a). (x + 1) - i'"]) 
apply wp
apply clarsimp
apply (auto simp: field_simps)
sledgehammer
*)

lemma "
  \<lbrace> \<lambda> a. f \<le> 3 \<rbrace> 
 sum' f
  \<lbrace> \<lambda> s a.  2*s = f * (f + 1) \<rbrace>!
"
apply (rule validNF_assume_pre)
apply (unfold sum'_def)
apply clarsimp
(* apply (subst whileLoop_add_inv [where I = " \<lambda> (i,sum) s. sum = ((i-1) * i) div 2" and M = "\<lambda>((i,sum),s). to - i"]) *)
apply (subst whileLoop_add_inv [where I = " \<lambda> (i,s') a. (i \<le> f \<longrightarrow> (\<exists>x. s' = x + ((i-1) * i) div 2))" and M = "\<lambda>((i,s'),a). to - i"]) 
apply wp
apply clarsimp
apply (auto simp: field_simps)
defer
sledgehammer
*)
end

end